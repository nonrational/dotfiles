{"mode":"editor","version":1,"windowDimensions":{"x":528,"y":86,"width":1433,"height":1151,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["atom://.atom/config"],"buffers":[{"text":"","markerStore":{"nextMarkerId":11,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":3,"nextCheckpointId":3,"undoStack":[],"redoStack":[{"type":"group-end","snapshot":{"0":{"range":[[147,266],[147,266]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[0,0]],"oldText":"","newText":""}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[147,266]],"oldText":"","newText":"# Test Track\nAuthor <john@betterment.com> <adam@betterment.com> <alan@betterment.com> <sam@betterment.com>\n\nDate 2015-10-09\n\n## Background\n\nIn order to finish decoupling retail from broker dealer, we need to deprecate all end-user-facing Java APIs.  Our homebrew split testing framework represents a significant set of those java endpoints.  Given the operational pain points associated with using the existing split testing framework, and the relative complexity of the whole system, we decided to replace rather than port the system as it stands today.\n\n## Objective\n\nTo build a minimal framework enabling split testing and feature gating that is engineer, PM, and data science friendly.  It may not solve for all the use cases our present BettermentDB-backed visitor system provides (e.g. attribution tracking, ultimately providing referral payments and bonuses), but it should well-solve a comprehensive set of split testing and feature gating use cases, while not imposing roadblocks to solving attribution tracking in the best possible way down the line, as replacing both systems will be necessary before the legacy visitor system can be removed.\n\n## Overview\n\nTestTrack consists of several different components:\n\n* A database-backed rails application (`TestTrack`) with the following features:\n  * Database storage of\n    * splits and the assignment probabilities of their variants + history\n    * visitors and their assigned splits + history (notably the TestTrack app never assigns variants to visitors itself - the clients do)\n    * associations between visitors and identifiers (unique per identifier type, e.g. bettermentdb_user_id 444 may only be associated with a single visitor).\n  * Unauthenticated, client-side-accessible API for\n    * querying all running splits\n    * querying assigned variants for a visitor\n    * assigning a variant to a visitor\n    * assigning an identifier to a visitor\n  * Authenticated, server-side API for\n    * managing splits (creating/editing splits, variants, weightings)\n    * creating new identity types\n    * querying visitor and assigned variants for an identifier (for offline processes where the visitor ID is not present in the runtime)\n  * Administrative interface for\n    * Changing assignment probabilities on the fly\n    * Bulk-overriding previously-assigned visitors to different assignments by uploading a list of identifiers and the desired variant, recording the bulk override as an epoch boundary.\n* A browser-based JavaScript client with the following features:\n  * Ability to generate visitor IDs and cookie them\n  * Look up assignments and lazily assign visitors to split variants whenever a split is encountered (typically in view code), persisting the split assignment to the server\n  * Ability to associate a given visitor with an identifier\n* A server-side Ruby client with the following features:\n  * Prefetching and caching of split registry for the ruby client's use as well as dumped into DOM for JS client to skip a round-trip\n  * Ability to generate visitor IDs and cookie them\n  * Fetch split assignments and cache them into the DOM to save the JS client a round-trip\n  * Look up assignments and lazily assign visitors to split variants whenever a split is encountered (typically in view code), persisting the split assignment to the server\n  * Ability to associate a given visitor with an identifier\n  * A migration DSL for configuring splits and identifier types\n  * Ability to fetch visitor and split assignments based on identifier in order to perform splits offline (via authenticated API)\n* A server-side PHP client with the following features:\n  * Prefetching and caching of split registry to be dumped into DOM for JS client to skip a round-trip\n* A Chrome extension allowing a Betterment employee to:\n  * See which splits are running, and which and variants the current visitor has been assigned to\n  * Change the visitor's assignment for one or more splits.\n\nWe don't contemplate building any analysis tooling at this time.  We intend to ship enough data to Mixpanel to be able to leverage segmented funnels to analyze the results of a simple split test.  Data team will be able to use their usual workflows for deeper analysis.\n\n## Detailed Design\n\nOur most important requirements included scalability (needs to keep working during load spikes), fault tolerance (if all or part of TestTrack goes down, it can't cripple the UX), end-user speed (users shouldn't wait any longer than strictly necessary before we display them a split).\n\nThere are many potential tradeoffs between end-user speed and power of the framework.  For example, we could normalize visitor ID among different domains by having a cookie on the testtrack.betterment.com domain, but that would necessarily introduce additional end-user requests before we could reliably begin displaying splits.  We decided that using wildcard domain cookies to track visitor IDs (`*.betterment.com`, `*.bettermentforbusiness.com`, `*.bettermentinstitutional.com`) would provide us enough cross-app visibility of the same visitor (e.g. brochure and retail) while not introducing additional end-user-visible cost.  We tested this assumption by trying to imagine a split test that would need to meaningfully involve UX on both BI and retail, and concluded that it wasn't necessary.\n\nThat said, if an application on a different domain is aware of another application's identifier for a given visitor (e.g. BI happens to know the bettermentdb_user_id of an advisor in a trustworthy way), BI can post an identifier association, and the visitor_ids will merge across the domains, allowing synchronization of split variants from that moment onward for that visitor.\n\nThis middle ground of being able to identify against IDs owned by other apps is also very useful for cases where a given feature needs to cross apps such as retail and broker dealer.  If we are dark launching a feature with both UX and trading impact, we can have both apps reference the same split, and guarantee a cohesive user experience for that end-user.\n\nWe chose to make split assignment and visitor ID generation a client side function so that we could make split test decisions for a brand new visitor purely on the client side with no UX latency.  Only after a given split variant is decided is an asynchronous API called to store the visitor ID and variant selection to TestTrack.  Given that the  majority of spike traffic is often confined to a single first page view, this design ensures optimal end-user experience for a new visitor.\n\nWe also selected a hybrid ruby/javascript client strategy for apps that support dynamic server side pages in order to cut down on UX latency even further for known visitors.  Because TestTrack supports overrides, assignments can't be purely deterministic based on the weightings and a hash of the visitor ID (as they would be if there were no overrides).  Therefore we must make a request to TestTrack to get the visitor's assignments whenever we need to show a variant.  Making this the responsibility of the JS client means that the customer would need to wait for 2X, where X is their ping time to our servers (not counting additional TCP connection establishment overhead), before we'd be able to show them a split.  Because the ruby client can also read the visitor_id cookie, it can prefetch the assignments for that visitor and stuff them in the DOM.  Our servers have an incredibly low ping time amongst themselves, so having the ruby client grab the assignments and stuff them in the DOM means that the JS can assign as soon as the page is loaded, at a cost of no more than low double digit milliseconds.\n\nA similar strategy is employed for shipping the split registry to the JS client, except it can be cached even more aggressively, because we have established a rule that all past split variants remain valid forever, even if they are no longer probabalistically assigned.  So the ruby client may cache the split registry for some short period of time (say 5 seconds) and drastically reduce the number of requests it would need to make to TestTrack under high load.  On WordPress, we can even cache the split registry right into the CDN-served pages, and blow the CDN cache whenever we want users to start receiving new variant assignment probabilities.\n\n## Data model\n\nhttps://github.com/Betterment/test_track/blob/master/db/schema.rb\n\n(schema for bulk overrides and epoch records TBD)\n\n## UI Impact\n\n* For end users\n  * Faster split assignments that should remain functional and consistent during load spikes\n* For engineers\n  * Creating and managing splits is done via a DSL in standard rails migrations, meaning there's no additional manual steps to release a new split test, or amend its weightings\n  * Splits can be performed in JS or Ruby code via a simple DSL\n  * We envision adding a Java client as well to enable trading functionality to leverage the feature gating as well\n* For PMs\n  * Use the nice UX that mixpanel already built to evaluate test results\n  * Simple UX to change variant weightings after calling a split\n  * Semi-simple UX to reassign people who have already been assigned\n  * Lazy assignment means that we don't need to reassign people nearly as much in order to steer more population into different variants over time.\n* For data scientists\n  * No significant changes needed to analysis workflow - mixpanel events will cover all the important activity, as always\n  * Addition of semantic epoch records makes it easier and safer to design analyses\n  * Automatic flagging of people whose splits have been individually manually overridden (as distinct from intentional bulk overrides) enables data team to easily exclude tainted visitors from analysis\n\n\n## Interface to Rest of System\n\nApplications simply install the gem and/or bower library, integrate the split variant conditionals into their views, and they're done.\n\n## Migration Plan\n\nTestTrack will run in parallel to the existing visitor system for some time, as there are split tests already running in the existing system, as well as features that TestTrack doesn't support (attribution).  Once we're happy with TestTrack's capabilities (and all running split tests against the legacy system ahve ended) and have figured out how to replace our existing attribution system, we'll switch the legacy system off.\n\n## Testing Plan\n\nWe are unit testing the server and clients in isolation using our standard patterns (WebMock for API clients, FakeableHer for adjacent models).  The server also has controller specs.  We're able to use Travis for CI because each app is in its own repo.  In practice, we've been able to roll out new server features without ever having run the server locally before deploying it to communicate with a client library.\n\n## Infrastructure\n\nTestTrack will have real production-style server instances in each of the AWS environments (develop, stage, production, one-offs).  This is different than the rest of the app suite, which uses a different branch of each app in the suite - TestTrack will always run master, regardless of the environment.  The TestTrack instances will be long-lived as well with no data-pushback during weekly deploys, each environment receiving configuration as the dependant apps run migrations to configure splits and identifier types.\n\n## Simplicity\n\n### What makes this design the net simplest solution to the problem?\n\nThis app is a complicated balancing act of software complexity, operational complexity, and runtime overhead.\n\nWe cut software complexity:\n\n* No analysis tools\n\nWe cut operational complexity:\n\n* Wrapped up split config in migration DSL\n* Wrapped up one-off overrides in a CRX\n* Wrapped up variant probability changes and bulk overrides in a web admin\n\nWe cut runtime overhead:\n\n* Client side assignment\n* Lazy assignment\n* split registry caching\n* sidestepped ping time with hybrid browser/server clients\n\n### Alternatives Considered\n\nKissMetrics provides a similar model for split testing, but we were hesitant to bring KissMetrics into the fold again after having rejected it in favor of MixPanel in the past (potentially introducing more performance penalties to the UX into the bargain).  Also KissMetrics would hit the wall when it came to cross-domain interoperability, if we find that to be important at some point.  KissMetrics would also not provide a centralized admin solution for changing split ratios or bulk overriding assignments, nor an easy way to manipulate an individual visitor's splits without building additional tooling.  Fundamentally, many of the pieces we built here would have been necessary to integrate with a third party solution and provide the feature set we have.  The only thing we would've avoided building by choosing another solution would be the TestTrack datastore itself, and that would inevitably come with some loss of end-user performance and flexibility.\n\n## Glossary\n\n* `split` - Splits are the core of TestTrack.  A split has a name (e.g. `button_color`) and a set of variants with assignment probability weightings summing to 100 (e.g. `red: 50, blue: 50`), represented as a `split registry`.\n* `visitor` - A person identified by a UUID.  Not the same as our legacy visitor system.\n* `assignment` - An assignment of a visitor to a split variant.\n* `split registry` - Per-split mapping between variant names and probabilities of assignment, summing to 100.\n* `assignment registry` - Per-visitor mapping between split names and the variant of each split that the visitor is assigned to\n* `identifier type` - A class of consumer-application-specific identifier.  Examples include `bettermentdb_lead_id`, `bettermentdb_user_id`, `institutional_advisor_id`\n* `identifier` - An assignment of a visitor to a given string value for a given identifier type.  This allows TestTrack to automatically swap and merge visitors when we learn that a previously-unknown visitor is in fact somebody we've seen before.\n* `epoch` - A period of time during which no bulk reassignments occurred on a given split test.  When performing complicated analysis, TestTrack's recording of epochs allow the data team to make informed choices about the time periods over which to perform sampling."}},{"type":"group-start","snapshot":{"0":{"range":[[0,0],[0,0]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}}]},"encoding":"utf8","preferredLineEnding":"\n","deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrapped":false,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"focused":true,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{},"metrics":{"sessionLength":491992},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"atom://.atom/config":{"isExpanded":true,"entries":{}}},"hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}